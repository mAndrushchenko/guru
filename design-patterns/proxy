## Structural Design Patterns

### Proxy pattern

**Замісник** - це структурний патерн проектування, що дає
змогу замість реальних об’єктів надає спеціальні
об’єкти-замінники. Ці обʼєкти перехоплюють виклики до оригінального об’єкта, дозволяючи зробити щось до чи після передачі виклику оригіналу. Тобото, це свого роду посередник, який дозволяє зробити якість додаткові маніпуляції, до того як віддати повний контроль над обʼєктом.

Він використовується для:
* Лінива ініціалізація (віртуальний проксі). Коли у вас є важкий об'єкт, який завантажує дані з файлової системи або бази даних.
* Захист доступу (захист проксі). Коли програма має різні типи користувачів, і вам хочеться захищати об'єкт від неавторизованого доступу. Проксі може перевіряти доступ під час кожного виклику та надсилати виконання службовому об'єкту, якщо доступ дозволено.
* Локальний запуск сервісу (віддалений проксі). Коли цей сервісний об'єкт знаходиться на віддаленому сервері. Ми пишемо код, який отримує виклик методу, якимось чином передає його по мережі та викликає такий самий метод віддаленого об'єкта.
* Логування запитів (що логує проксі). Коли потрібно зберігати історію звернень до об'єкта обслуговування.
* Кешування об'єктів («розумне» посилання). Коли потрібно кешувати результати запитів клієнтів та керувати їх життєвим циклом.

> Життєвий приклад:: Уявіть, що ви їдете у відпустку або тимчасово відсутні, і ваш друг чи співробітник стає вашою довіреною особою. Вони можуть виступати в ролі проксі для вас у багатьох ситуаціях, таких як підписання документів, управління вашими фінансами або відвідування зустрічі.

**Переваги та недоліки**

* ✅Дозволяє контролювати сервісний об’єкт непомітно для
  клієнта.

* ✅Може працювати, навіть якщо сервісний об’єкт ще не
  створено.

* ✅Може контролювати життєвий цикл службового об’єкта.


* ❌Ускладнює код програми внаслідок введення додаткових
  класів.
* ❌Збільшує час отримання відклику від сервісу.

**Лінива ініціалізація**
```tsx
// Створюємо об'єкт, який представлятиме віртуальний проксі
const lazyInitializedObject = new Proxy({}, {
	get: function(target, property) {
		// При зверненні до властивостей об'єкта, виконуємо ліниву ініціалізацію
		if (!target[property]) {
			console.log(`Виконується лінива ініціалізація властивості "${property}"`);
			// Симулюємо дорогу операцію, наприклад, отримання даних з сервера
			target[property] = `Дані для властивості "${property}"`;
		}
		// Повертаємо значення властивості
		return target[property];
	}
});

// При кожному зверненні до властивостей об'єкта буде виконуватися лінива ініціалізація
console.log(lazyInitializedObject.first); // Виконується лінива ініціалізація властивості "first"
console.log(lazyInitializedObject.first); // Дані для властивості "first"

console.log(lazyInitializedObject.second); // Виконується лінива ініціалізація властивості "second"
console.log(lazyInitializedObject.second); // Дані для властивості "second"
```

**Захист доступу **
```tsx
// Створюємо об'єкт, який ми будемо захищати
const protectedObject = {
    username: "user123",
    password: "securepassword"
};

// Функція-перехоплювач для перевірки доступу до властивостей об'єкта
const accessControlHandler = {
    get: function(target, property) {
        // Перевіряємо доступ до властивості "password"
        if (property === "password") {
            console.log("Доступ заборонено: ви намагаєтесь отримати доступ до пароля.");
            return undefined; // Забороняємо доступ до властивості "password"
        }
        // В інших випадках, повертаємо значення властивості
        return target[property];
    },
    set: function(target, property, value) {
        // Перевіряємо доступ до властивостей, які не можна змінювати
        if (property === "username") {
            console.log("Доступ заборонено: ви намагаєтесь змінити значення властивості 'username'.");
            return false; // Забороняємо зміну властивості "username"
        }
        // В інших випадках, дозволяємо зміну властивостей
        target[property] = value;
        return true;
    }
};

// Створюємо захищений об'єкт за допомогою проксі з функцією-перехоплювачем для управління доступом
const protectedProxy = new Proxy(protectedObject, accessControlHandler);

// При спробі отримати доступ до пароля буде виведено повідомлення про заборону доступу
console.log(protectedProxy.password); // Доступ заборонено: ви намагаєтесь отримати доступ до пароля.
// При спробі змінити властивість "username" буде виведено повідомлення про заборону зміни
protectedProxy.username = "newUser"; // Доступ заборонено: ви намагаєтесь змінити значення властивості 'username'.
```

**Локальний запуск сервісу**
```tsx
/ Віддалений сервіс, який містить методи для отримання даних
class RemoteService {
  fetchData() {
    console.log('Віддалений сервіс: виконується запит на отримання даних');
    // Симуляція віддаленого запиту
    return new Promise(resolve => {
      setTimeout(() => {
        resolve("Дані з віддаленого сервісу");
      }, 2000);
    });
  }
}

// Локальний проксі для взаємодії з віддаленим сервісом
class LocalProxy {
  constructor() {
    this.remoteService = new RemoteService(); // Створюємо екземпляр віддаленого сервісу
  }

  // Метод для отримання даних, використовуючи віддалений проксі
  async fetchData() {
    console.log('Локальний проксі: виконується запит на отримання даних через віддалений сервіс');
    return this.remoteService.fetchData(); // Викликаємо метод віддаленого сервісу
  }
}

// Використання локального проксі для отримання даних
const localProxy = new LocalProxy();
localProxy.fetchData().then(data => {
  console.log('Дані отримані через локальний проксі:', data);
});
```

** Логування запитів **
```tsx
// Функція-перехоплювач для логування запитів
const loggingProxy = target => {
    return new Proxy(target, {
        get: function(target, property) {
            const value = target[property];
            if (typeof value === 'function') {
                // Логуємо ім'я методу, який був викликаний
                console.log(`Викликано метод: ${property}`);
                // Повертаємо обгорнутий метод
                return function(...args) {
                    // Логуємо аргументи, з якими був викликаний метод
                    console.log(`Аргументи: ${JSON.stringify(args)}`);
                    // Викликаємо оригінальний метод та повертаємо його результат
                    const result = value.apply(target, args);
                    // Логуємо результат виклику методу
                    console.log(`Результат: ${JSON.stringify(result)}`);
                    return result;
                };
            } else {
                // Якщо це не функція, просто повертаємо значення
                return value;
            }
        }
    });
};

// Об'єкт, який ми будемо обгортати
const calculator = {
    add: (a, b) => a + b,
    subtract: (a, b) => a - b
};

// Створюємо проксі для об'єкта calculator з функцією-перехоплювачем для логування
const loggedCalculator = loggingProxy(calculator);

// Викликаємо методи обгорнутого об'єкта, які будуть логуватися в консолі
console.log(loggedCalculator.add(5, 3)); // Викликано метод: add
                                         // Аргументи: [5,3]
                                         // Результат: 8

console.log(loggedCalculator.subtract(10, 4)); // Викликано метод: subtract
                                               // Аргументи: [10,4]
                                               // Результат: 6
//У цьому прикладі ми створюємо проксі loggedCalculator для об'єкта calculator, який містить методи add та subtract.
// Функція-перехоплювач проксі перехоплює виклики цих методів та логує їх назву, передані аргументи та результат виклику у консоль.
// Таким чином, ми можемо легко відстежувати виклики методів та їх параметри в нашій програмі.
```

**Кешування об'єктів**
```tsx
// Функція для обчислення факторіалу
function calculateFactorial(n) {
    console.log(`Обчислюємо факторіал для ${n}`);
    let result = 1;
    for (let i = 2; i <= n; i++) {
        result *= i;
    }
    return result;
}

// Функція-перехоплювач для кешування результатів функції
const cachingProxy = targetFunction => {
    const cache = {}; // Об'єкт-кеш для зберігання результатів

    return new Proxy(targetFunction, {
        apply: function(target, thisArg, args) {
            const key = args.join('-'); // Створюємо ключ на основі аргументів
            if (cache[key] === undefined) { // Перевіряємо, чи результат вже є в кеші
                cache[key] = target.apply(thisArg, args); // Викликаємо оригінальну функцію і зберігаємо результат в кеші
            }
            return cache[key]; // Повертаємо результат з кешу
        }
    });
};

// Створюємо кешовану версію функції для обчислення факторіалу
const cachedCalculateFactorial = cachingProxy(calculateFactorial);

// Перший виклик, обчислення факторіалу для 5
console.log(cachedCalculateFactorial(5)); // Виводить: Обчислюємо факторіал для 5
                                           // Виводить: 120

// Другий виклик з тими самими аргументами
console.log(cachedCalculateFactorial(5)); // Виводить: 120 (результат береться з кешу, обчислення не відбувається знову)

// Третій виклик для іншого значення
console.log(cachedCalculateFactorial(10)); // Виводить: Обчислюємо факторіал для 10
                                            // Виводить: 3628800
```
